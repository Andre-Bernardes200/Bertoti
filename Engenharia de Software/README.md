## Texto aula 1
We see three critical differences between programming and software engineering: time, scale, and the trade-offs at play. On a software engineering project, engineers need to be more concerned with the passage of time and the eventual need for change. In a software engineering organization, we need to be more concerned about scale and efficiency, both for the software we produce as well as for the organization that is producing it. Finally, as software engineers, we are asked to make more complex decisions with higher-stakes outcomes, often based on imprecise estimates of time and growth.

### Comentários

Pelo que entendi do texto é que o engenheiro de software tem que se preocupar a longo prazo da necessidade de mudança, ele precisa se preocupar em projetar algo para o uso a longo prazo. Precisa saber o seu tamanho e sua eficiência para o projeto desejado, avaliar se vai compensar ou não e tomar decisões com base nisso.

O engenheiro de software precisa de dados para se basear em sua decisão, mas como às vezes ele é chamado para tomar decisão de alto risco ele sai de sua zona de conforto e precisa falar algo que pode dar certo no momento e pode funcionar bem a longo prazo, mas ele não tem essa garantia.


## Texto aula 2 

Within Google, we sometimes say, “Software engineering is programming integrated over time.” Programming is certainly a significant part of software engineering: after all, programming is how you generate new software in the first place. If you accept this distinction, it also becomes clear that we might need to delineate between programming tasks (development) and software engineering tasks (development, modification, maintenance). The addition of time adds an important new dimension to programming. Cubes aren’t squares, distance isn’t velocity. Software engineering isn’t programming.

### Comentários







## Aula 3


    https://www.nngroup.com/articles/ten-usability-heuristics/

 # Perguntas: 

 ### Sobre qual requisito não funcional este texto fala?

 Sobre o requisito da usabilidade dos usuários com o sistema.

 ### Qual a importância?

Sua importância é que uma usuário não deve precisar se lembrar das coisas para acessar ao sistema, ele deve ser prático, de fácil reconhecimento e também deve conseguir auxiliar seu usuário para caso entre em um lugar errado consiga sair fácil ou também caso o dê um erro no sistema ele consiga entender o erro sem precisar de detalhes técnicos.

### Como "obter" este requisito não funcional no meu software ?

Ele deve ser feito pensando no usuário. Pensando no que deve ser fácil para ele e atráves de pesquisas e também analisando como deixar o sistema o mais intuitivo possível para o usuário. 

 ### Encontre 1 erro e 1 acerto de cada Heurística.

  #### Visibilidade do status do sistema:

    Erro: Designs muito complexos dependendo da pessoa que está visualizando.

    Acerto: Bons feedback's com suas respostas apropriadas e também num tempo razoável para o usuário não se irritar.

  #### Correspondência entre o sistema e o mundo real:

    Erro: Conceitos que não é familiar a todos os usuários e às vezes é familiar a somente um determinado público alvo de usuários.

    Acerto: Usando convenções no mundo real auxilia e é mais fácil para os usuários aprenderem e lembrarem de como a interface funciona.

  #### Controle e liberdade do usuário:

    Erro: O usuário ter liberdade demais e acabar fazendo ações indesejadas e não conseguir desfaze-las.

    Acerto: Suporte para desfazer e refazer uma determinada ação.

  #### Consistência e padrões:

    Erro: Os usuários ficarem confusos com os padrões e acharem que estão fazendo a mesma coisa.

    Acerto: A falta de consistência para forçar aos usuários melhorarem a capacidade de aprendizado.

  #### Prevenção de erros:

    Erros: Poucas mensagens de erro, isso dificulta os usuários se lembrarem quando fizeram algo errado.

    Acertos: Uma quantidade menor de erros significa que o sistema é mais bem feito e dificulta os usuários darem bug no sistema.

  #### Reconhecimento em vez de recordação

    Erros: Poucas informações, isso dificulta os usuários de vez em quando a lembrarem sobre a ação que desejam fazer.

    Acertos: Interfaces intuitivas ajudam o usuário a se adaptar ao aplicativo e mais prático.

  #### Flexibilidade e eficiência de uso

    Erros: Processos muitos flexíveis pode dificultar a comunicação entre um usuário e outro.

    Acertos: Escolher o método que o usuário melhor se adaptar.

  #### Design estético e minimalista

    Erros: Às vezes poucas informações pode deixar o usuário carente de informações.

    Acertos: Evita pouca poluição visual e deixa o usuário mais ligado no sistema.

  #### Ajude os usuários a reconhecer, diagnosticar e se recuperar de erros

    Erros:Linguagens muito simples pode complicar ainda mais o usuário entender o motivo do erro.

    Acertos: Oferta de atalhos para resolução do sistema.

  #### Ajuda e documentação

    Erros: Documentações complexas e que não auxiliam a achar a resposta para o seu problema.

    Acertos: Documentação só aparece quando o usuário necessita dela.